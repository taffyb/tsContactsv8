//import { Component, ElementRef, Input, OnChanges, OnInit, ViewChild, ViewEncapsulation } from '@angular/core';
//import * as d3 from 'd3';
//import { DataModel } from '../data/data.model';
//
//@Component({
//    selector: 'app-canvas',
//    encapsulation: ViewEncapsulation.None,
//    templateUrl: './canvas.component.html',
//    styleUrls: ['./canvas.component.css']
//  })
//  export class CanvasComponent implements OnChanges {
//    @ViewChild('canvas', {read: ElementRef,static:true})
//    private chartContainer: ElementRef;
//
//    @Input()
//    data: DataModel;
//
//    margin = {top: 20, right: 20, bottom: 30, left: 40};
//
//    constructor() { }
//
//    ngOnChanges(): void {
//      if (!this.data) { return; }
//      console.log(`Data: ${JSON.stringify(this.data)}`);
////      this.createChart();
//    }
//
////    private createChart(): void {
////      d3.select('svg').remove();
////
////      const element = this.chartContainer.nativeElement;
////      const data = this.data;
////
////      const svg = d3.select(element).append('svg')
////          .attr('width', element.offsetWidth)
////          .attr('height', element.offsetHeight);
////      const color = d3.scaleOrdinal(d3.schemeCategory10);
////      
////      const contentWidth = element.offsetWidth - this.margin.left - this.margin.right;
////      const contentHeight = element.offsetHeight - this.margin.top - this.margin.bottom;
//
////      const simulation = d3.forceSimulation()
////      .force("link", d3.forceLink().id(function(d) { return d.id; }))
////      .force("charge", d3.forceManyBody())
////      .force("center", d3.forceCenter(contentWidth / 2, contentHeight / 2));
//      
////      const x = d3
////        .scaleBand()
////        .rangeRound([0, contentWidth])
////        .padding(0.1)
////        .domain(data.map(d => d.letter));
////
////      const y = d3
////        .scaleLinear()
////        .rangeRound([contentHeight, 0])
////        .domain([0, d3.max(data, d => d.frequency)]);
//
////          const force = self.force = d3.layout.force()
////              .nodes(data.nodes)
////              .links(data.links)
////              .gravity(.05)
////              .distance(100)
////              .charge(-100)
////              .size([contentWidth, contentHeight])
////              .start();
////
////          const link = element.selectAll("line.link")
////              .data(data.links)
////              .enter().append("svg:line")
////              .attr("class", "link")
////              .attr("x1", function(d) { return d.source.x; })
////              .attr("y1", function(d) { return d.source.y; })
////              .attr("x2", function(d) { return d.target.x; })
////              .attr("y2", function(d) { return d.target.y; });
//
////          const node_drag = d3.behavior.drag()
////              .on("dragstart", dragstart)
////              .on("drag", dragmove)
////              .on("dragend", dragend);
////
////          function dragstart(d, i) {
////              force.stop() // stops the force auto positioning before you start dragging
////          }
////
////          function dragmove(d, i) {
////              d.px += d3.event.dx;
////              d.py += d3.event.dy;
////              d.x += d3.event.dx;
////              d.y += d3.event.dy; 
////              tick(); // this is the key to make it work together with updating both px,py,x,y on d !
////          }
////
////          function dragend(d, i) {
////              d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
////              tick();
////              force.resume();
////          }
////
////
////          var node = element.selectAll("g.node")
////              .data(data.nodes)
////            .enter().append("svg:g")
////              .attr("class", "node")
////              .call(node_drag);
////
////          node.append("svg:image")
////              .attr("class", "circle")
////              .attr("xlink:href", "https://github.com/favicon.ico")
////              .attr("x", "-8px")
////              .attr("y", "-8px")
////              .attr("width", "16px")
////              .attr("height", "16px");
////
////          node.append("svg:text")
////              .attr("class", "nodetext")
////              .attr("dx", 12)
////              .attr("dy", ".35em")
////              .text(function(d) { return d.name });
////
////          force.on("tick", tick);
////
////          function tick() {
////            link.attr("x1", function(d) { return d.source.x; })
////                .attr("y1", function(d) { return d.source.y; })
////                .attr("x2", function(d) { return d.target.x; })
////                .attr("y2", function(d) { return d.target.y; });
////
////            node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
////          };
////
////
////      }
//  }
